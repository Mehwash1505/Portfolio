"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rehype-pretty-code";
exports.ids = ["vendor-chunks/rehype-pretty-code"];
exports.modules = {

/***/ "(rsc)/./node_modules/rehype-pretty-code/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/rehype-pretty-code/dist/index.js ***!
  \*******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ src_default),\n/* harmony export */   rehypePrettyCode: () => (/* binding */ rehypePrettyCode)\n/* harmony export */ });\n/* harmony import */ var shiki__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shiki */ \"shiki\");\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unist-util-visit */ \"(rsc)/./node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-to-string */ \"(rsc)/./node_modules/hast-util-to-string/lib/index.js\");\n/* harmony import */ var parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! parse-numeric-range */ \"(rsc)/./node_modules/parse-numeric-range/index.js\");\n/* harmony import */ var unified__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unified */ \"(rsc)/./node_modules/unified/lib/index.js\");\n/* harmony import */ var rehype_parse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rehype-parse */ \"(rsc)/./node_modules/rehype-parse/lib/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([shiki__WEBPACK_IMPORTED_MODULE_0__]);\nshiki__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n\n// src/index.ts\nfunction isJSONTheme(value) {\n    return value ? Object.hasOwn(value, \"tokenColors\") : false;\n}\nfunction isElement(value) {\n    return value ? value.type === \"element\" : false;\n}\nfunction isText(value) {\n    return value ? value.type === \"text\" : false;\n}\nfunction isInlineCode(element, parent, bypass = false) {\n    if (bypass) {\n        return false;\n    }\n    return element.tagName === \"code\" && isElement(parent) && parent.tagName !== \"pre\" || element.tagName === \"inlineCode\";\n}\nfunction isBlockCode(element) {\n    return element.tagName === \"pre\" && Array.isArray(element.children) && element.children.length === 1 && isElement(element.children[0]) && element.children[0].tagName === \"code\";\n}\nfunction getInlineCodeLang(meta, defaultFallbackLang) {\n    const placeholder = \"\\x00\";\n    let temp = meta.replace(/\\\\\\\\/g, placeholder);\n    temp = temp.replace(/\\\\({:[a-zA-Z.-]+})$/, \"$1\");\n    const lang = temp.match(/{:([a-zA-Z.-]+)}$/)?.[1];\n    return lang?.replace(new RegExp(placeholder, \"g\"), \"\\\\\") || defaultFallbackLang;\n}\nfunction parseBlockMetaString(element, filter, defaultFallback) {\n    let meta = filter(element.data?.meta ?? element.properties?.metastring ?? \"\");\n    const titleMatch = meta.match(/title=\"([^\"]*)\"/);\n    const title = titleMatch?.[1] ?? null;\n    meta = meta.replace(titleMatch?.[0] ?? \"\", \"\");\n    const captionMatch = meta.match(/caption=\"([^\"]*)\"/);\n    const caption = captionMatch?.[1] ?? null;\n    meta = meta.replace(captionMatch?.[0] ?? \"\", \"\");\n    let lang = defaultFallback;\n    if (element.properties && Array.isArray(element.properties.className) && typeof element.properties.className[0] === \"string\" && element.properties.className[0].startsWith(\"language-\")) {\n        lang = element.properties.className[0].replace(\"language-\", \"\");\n    }\n    return {\n        title,\n        caption,\n        lang,\n        meta\n    };\n}\nfunction getThemeNames(theme) {\n    if (isJSONTheme(theme)) {\n        return [\n            theme.name\n        ];\n    }\n    if (typeof theme === \"string\") {\n        return [\n            theme\n        ];\n    }\n    return Object.values(theme).map((theme2)=>typeof theme2 === \"string\" ? theme2 : theme2.name);\n}\nfunction replaceLineClass(element) {\n    if (Array.isArray(element.properties?.className) && element.properties.className.includes(\"line\")) {\n        const className = element.properties.className.filter((c)=>c !== \"line\");\n        element.properties.className = className.length > 0 ? className : void 0;\n        element.properties[\"data-line\"] = \"\";\n    }\n}\nfunction getLineId(lineNumber, meta) {\n    const segments = meta.match(/\\{[^}]+\\}#[a-zA-Z0-9]+/g);\n    if (!segments) return null;\n    for (const segment of segments){\n        const [range, id] = segment.split(\"#\");\n        if (!(range && id)) continue;\n        const match = range.match(/\\{(.*?)\\}/);\n        const capture = match?.[1];\n        if (capture && parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__(capture).includes(lineNumber)) {\n            return id;\n        }\n    }\n    return null;\n}\n// src/chars/splitElement.ts\nfunction splitElement({ elements, elementToWrap, innerString, rightString, leftString, rest, nextElementContinues, index, ignoreChars }) {\n    if (isElement(elementToWrap) && elementToWrap.children?.[0]?.type !== \"text\" || ignoreChars) {\n        return [\n            elementToWrap,\n            index\n        ];\n    }\n    let newIndex = index;\n    const textElement = elementToWrap.children[0];\n    if (isText(textElement)) {\n        textElement.value = innerString;\n    }\n    let rightStr = rightString;\n    const leftStr = leftString;\n    if (rest.length > 0) {\n        rightStr += rest.map((s)=>s === \"\" ? innerString : innerString + s).join(\"\");\n    }\n    if (leftStr.length > 0) {\n        elements.splice(newIndex, 0, {\n            ...elementToWrap,\n            properties: {\n                ...elementToWrap.properties\n            },\n            children: [\n                {\n                    type: \"text\",\n                    value: leftStr\n                }\n            ]\n        });\n    }\n    if (rightStr.length > 0 && !nextElementContinues) {\n        newIndex = leftStr.length > 0 ? newIndex + 2 : newIndex + 1;\n        elements.splice(newIndex, 0, {\n            ...elementToWrap,\n            properties: {\n                ...elementToWrap.properties\n            },\n            children: [\n                {\n                    type: \"text\",\n                    value: rightStr\n                }\n            ]\n        });\n    }\n    return [\n        elementToWrap,\n        index + 1\n    ];\n}\nfunction nextElementMaybeContinuesChars({ elements, nextIndex, remainingPart }) {\n    if (remainingPart === \"\") {\n        return false;\n    }\n    const nextNode = elements[nextIndex];\n    const content = getContent(nextNode);\n    if (!content) {\n        return false;\n    }\n    const includesNext = content.startsWith(remainingPart) || remainingPart.startsWith(content);\n    const overlap = findOverlap(content, remainingPart);\n    if (overlap === remainingPart && content.startsWith(remainingPart)) {\n        return true;\n    }\n    if (includesNext) {\n        return nextElementMaybeContinuesChars({\n            elements,\n            nextIndex: nextIndex + 1,\n            remainingPart: remainingPart.replace(content, \"\")\n        });\n    }\n    return false;\n}\nfunction getContent(node) {\n    if (!node) return;\n    return (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(node);\n}\nfunction findOverlap(a, b) {\n    if (b.length === 0) {\n        return \"\";\n    }\n    if (a.endsWith(b)) {\n        return b;\n    }\n    if (a.indexOf(b) >= 0) {\n        return b;\n    }\n    return findOverlap(a, b.substring(0, b.length - 1));\n}\nfunction reverseString(s) {\n    return s.split(\"\").reverse().join(\"\");\n}\n// src/chars/getElementsToHighlight.ts\nfunction getElementsToHighlight(element, chars, startIndex = 0, ignoreChars = false) {\n    const toWrap = [];\n    let charsSoFar = \"\";\n    if (element.children) {\n        const elements = element.children;\n        for(let i = startIndex; i < elements.length; i++){\n            const remaining = charsSoFar ? chars.replace(charsSoFar, \"\") : chars;\n            if (remaining === \"\") {\n                return toWrap;\n            }\n            const maybeElement = elements[i];\n            if (!maybeElement || maybeElement.type !== \"element\" || // ignore any previously matched chars within\n            Object.hasOwn(maybeElement.properties ?? {}, \"rehype-pretty-code-visited\")) {\n                continue;\n            }\n            const content = getContent(maybeElement) || \"\";\n            if (content === chars || charsSoFar + content === chars) {\n                toWrap.push({\n                    element: maybeElement,\n                    index: i\n                });\n                return toWrap;\n            }\n            if (chars.startsWith(charsSoFar + content)) {\n                if (nextElementMaybeContinuesChars({\n                    elements,\n                    nextIndex: i + 1,\n                    remainingPart: remaining.replace(content, \"\")\n                })) {\n                    toWrap.push({\n                        element: elements[i],\n                        index: i\n                    });\n                    charsSoFar += content;\n                    continue;\n                }\n            }\n            const overlap = findOverlap(content, remaining);\n            const partialMatch = overlap && remaining.startsWith(overlap);\n            if (partialMatch) {\n                const nextPart = remaining.replace(overlap, \"\");\n                if (nextPart !== \"\" && getContent(elements[i + 1]) && !nextElementMaybeContinuesChars({\n                    elements,\n                    nextIndex: i + 1,\n                    remainingPart: nextPart\n                })) {\n                    continue;\n                }\n                const splitParts = content.split(overlap);\n                const [leftPart, rightPart, ...rest] = splitParts;\n                if (rightPart || leftPart || rest.length > 0) {\n                    const withNextNode = content + (getContent(elements[i + 1]) ? getContent(elements[i + 1]) : \"\");\n                    const nextNodeOverlap = findOverlap(withNextNode, remaining);\n                    const splitIndex = withNextNode.indexOf(nextNodeOverlap);\n                    if (chars.endsWith(overlap) || chars.startsWith(overlap)) {\n                        const rightString = rightPart.replace(overlap, \"\");\n                        const innerString = overlap;\n                        const leftString = content.substring(0, splitIndex);\n                        const nextElementContinues = nextElementMaybeContinuesChars({\n                            elements,\n                            nextIndex: i + 1,\n                            remainingPart: nextPart\n                        });\n                        const [newElement, updatedIndex] = splitElement({\n                            elements,\n                            elementToWrap: elements[i],\n                            innerString,\n                            rightString,\n                            leftString,\n                            rest,\n                            nextElementContinues,\n                            index: i,\n                            ignoreChars\n                        });\n                        charsSoFar += overlap;\n                        toWrap.push({\n                            element: newElement,\n                            index: updatedIndex\n                        });\n                    }\n                }\n            }\n        }\n    }\n    return toWrap;\n}\n// src/chars/wrapHighlightedChars.ts\nfunction wrapHighlightedChars(parentElement, elementsToWrap, options, ignoreWord, onVisitHighlightedChars) {\n    if (!elementsToWrap || elementsToWrap.length === 0) {\n        return;\n    }\n    const [{ element }] = elementsToWrap;\n    if (ignoreWord) {\n        if (element.properties) {\n            element.properties[\"rehype-pretty-code-visited\"] = \"\";\n        }\n        return;\n    }\n    if (elementsToWrap.length > 1) {\n        parentElement.children.splice(elementsToWrap[0].index, elementsToWrap.length, {\n            type: \"element\",\n            tagName: \"mark\",\n            properties: {\n                \"data-highlighted-chars-mark\": \"\"\n            },\n            children: elementsToWrap.map(({ element: element3 })=>element3)\n        });\n        const element2 = parentElement.children[elementsToWrap[0].index];\n        if (!isElement(element2)) {\n            return;\n        }\n        const wordStr = element2.children.reduce((acc, node)=>{\n            const textElement = isElement(node) ? node.children[0] : null;\n            if (isText(textElement)) {\n                return acc + textElement.value;\n            }\n            return acc;\n        }, \"\");\n        const id = options.idsMap.get(wordStr);\n        element2.properties = element2.properties || {};\n        element2.properties[\"data-highlighted-chars\"] = \"\";\n        element2.properties[\"data-chars-id\"] = id;\n        element2.tagName = \"mark\";\n        onVisitHighlightedChars?.(element2, id);\n    } else {\n        const [{ element: element2 }] = elementsToWrap;\n        const textElement = element2.children[0];\n        if (!isText(textElement)) {\n            return;\n        }\n        const id = options.idsMap.get(textElement.value);\n        element2.properties = element2.properties || {};\n        element2.properties[\"rehype-pretty-code-visited\"] = \"\";\n        element2.properties[\"data-highlighted-chars\"] = \"\";\n        element2.properties[\"data-chars-id\"] = id;\n        element2.tagName = \"mark\";\n        element2.children = [\n            {\n                type: \"element\",\n                tagName: \"span\",\n                properties: {\n                    style: element2.properties.style\n                },\n                children: element2.children\n            }\n        ];\n        element2.properties.style = void 0;\n        onVisitHighlightedChars?.(element2, id);\n    }\n}\nfunction charsHighlighter(element, charsList, options, onVisitHighlightedChars) {\n    const { ranges = [] } = options;\n    const textContent = (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(element);\n    charsList.forEach((chars, index)=>{\n        if (chars && textContent?.includes(chars)) {\n            let textContent2 = (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(element);\n            let startIndex = 0;\n            while(textContent2.includes(chars)){\n                const currentCharsRange = ranges[index] || [];\n                const id = `${chars}-${index}`;\n                options.counterMap.set(id, (options.counterMap.get(id) || 0) + 1);\n                const ignoreChars = currentCharsRange.length > 0 && !currentCharsRange.includes(options.counterMap.get(id) ?? -1);\n                const elementsToWrap = getElementsToHighlight(element, chars, startIndex, ignoreChars);\n                if (elementsToWrap.length === 0) break;\n                wrapHighlightedChars(element, elementsToWrap, options, ignoreChars, onVisitHighlightedChars);\n                startIndex = Math.max(elementsToWrap[elementsToWrap.length - 1].index - 2, 0);\n                textContent2 = element.children.map((childNode)=>{\n                    const props = isElement(childNode) ? childNode.properties : {};\n                    if (props && !Object.hasOwn(props, \"rehype-pretty-code-visited\") && !Object.hasOwn(props, \"data-highlighted-chars-mark\")) {\n                        return (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(childNode);\n                    }\n                }).join(\"\");\n            }\n        }\n    });\n    element.children.forEach((childNode)=>{\n        if (!isElement(childNode)) return;\n        if (Object.hasOwn(childNode.properties, \"rehype-pretty-code-visited\")) {\n            childNode.properties[\"rehype-pretty-code-visited\"] = void 0;\n        }\n    });\n}\n// src/index.ts\nfunction apply(element, { tree, lang, title, caption, inline = false, keepBackground = true, grid = true, lineNumbersMaxDigits = 1, theme, onVisitTitle, onVisitCaption }) {\n    element.tagName = inline ? \"span\" : \"figure\";\n    element.properties[\"data-rehype-pretty-code-figure\"] = \"\";\n    const codeData = element.children[0]?.data;\n    element.children = [\n        tree\n    ].flatMap((tree2)=>{\n        const pre = tree2.children[0];\n        const themeNames = getThemeNames(theme);\n        const themeNamesString = themeNames.join(\" \");\n        if (!(isElement(pre) && pre.properties)) {\n            return [];\n        }\n        const code = pre.children[0];\n        if (Array.isArray(pre.properties.className) && pre.properties.className.includes(\"shiki\")) {\n            const className = pre.properties.className.filter((c)=>c !== \"shiki\" && c !== \"shiki-themes\" && (typeof c === \"string\" ? !themeNames.includes(c) : true));\n            pre.properties.className = className.length > 0 ? className : void 0;\n        }\n        if (!keepBackground) {\n            pre.properties.style = void 0;\n        }\n        pre.properties[\"data-language\"] = lang;\n        pre.properties[\"data-theme\"] = themeNamesString;\n        if (!(isElement(code) && code.properties)) {\n            return [];\n        }\n        code.properties[\"data-language\"] = lang;\n        code.properties[\"data-theme\"] = themeNamesString;\n        code.data = codeData;\n        if (inline) {\n            if (keepBackground) {\n                code.properties.style = pre.properties.style;\n            }\n            return code;\n        }\n        if (grid) {\n            if (code.properties.style) {\n                code.properties.style += \"display: grid;\";\n            } else {\n                code.properties.style = \"display: grid;\";\n            }\n        }\n        if (Object.hasOwn(code.properties, \"data-line-numbers\")) {\n            code.properties[\"data-line-numbers-max-digits\"] = lineNumbersMaxDigits.toString().length;\n        }\n        const fragments = [];\n        if (title) {\n            const elementContent = {\n                type: \"element\",\n                tagName: caption ? \"div\" : \"figcaption\",\n                properties: {\n                    \"data-rehype-pretty-code-title\": \"\",\n                    \"data-language\": lang,\n                    \"data-theme\": themeNamesString\n                },\n                children: [\n                    {\n                        type: \"text\",\n                        value: title\n                    }\n                ]\n            };\n            onVisitTitle?.(elementContent);\n            fragments.push(elementContent);\n        }\n        fragments.push(pre);\n        if (caption) {\n            const elementContent = {\n                type: \"element\",\n                tagName: \"figcaption\",\n                properties: {\n                    \"data-rehype-pretty-code-caption\": \"\",\n                    \"data-language\": lang,\n                    \"data-theme\": themeNamesString\n                },\n                children: [\n                    {\n                        type: \"text\",\n                        value: caption\n                    }\n                ]\n            };\n            onVisitCaption?.(elementContent);\n            fragments.push(elementContent);\n        }\n        return fragments;\n    });\n}\nvar globalHighlighterCache = /* @__PURE__ */ new Map();\nvar hastParser = (0,unified__WEBPACK_IMPORTED_MODULE_3__.unified)().use(rehype_parse__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n    fragment: true\n});\nvar src_default = rehypePrettyCode;\nfunction rehypePrettyCode(options = {}) {\n    const { grid = true, theme = \"github-dark-dimmed\", keepBackground = true, bypassInlineCode = false, defaultLang = \"\", tokensMap = {}, filterMetaString = (v)=>v, getHighlighter = shiki__WEBPACK_IMPORTED_MODULE_0__.getSingletonHighlighter, transformers, onVisitLine, onVisitHighlightedLine, onVisitHighlightedChars, onVisitTitle, onVisitCaption } = options;\n    const key = JSON.stringify(theme);\n    let cachedHighlighter = globalHighlighterCache.get(key);\n    if (!cachedHighlighter) {\n        cachedHighlighter = getHighlighter({\n            themes: isJSONTheme(theme) || typeof theme === \"string\" ? [\n                theme\n            ] : Object.values(theme),\n            langs: [\n                \"plaintext\"\n            ]\n        });\n        globalHighlighterCache.set(key, cachedHighlighter);\n    }\n    const defaultCodeBlockLang = typeof defaultLang === \"string\" ? defaultLang : defaultLang.block || \"\";\n    const defaultInlineCodeLang = typeof defaultLang === \"string\" ? defaultLang : defaultLang.inline || \"\";\n    function getOptions(lang, meta) {\n        const multipleThemes = !isJSONTheme(theme) && typeof theme === \"object\" ? theme : null;\n        const singleTheme = isJSONTheme(theme) || typeof theme === \"string\" ? theme : null;\n        return {\n            lang,\n            meta: {\n                __raw: meta\n            },\n            transformers,\n            defaultColor: typeof theme === \"string\" ? theme : false,\n            ...multipleThemes ? {\n                themes: multipleThemes\n            } : {\n                theme: singleTheme\n            }\n        };\n    }\n    return async (tree)=>{\n        const langsToLoad = /* @__PURE__ */ new Set();\n        const highlighter = await cachedHighlighter;\n        if (!highlighter) return;\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(tree, \"element\", (element, _, parent)=>{\n            if (isInlineCode(element, parent, bypassInlineCode)) {\n                const textElement = element.children[0];\n                if (!isText(textElement)) return;\n                const value = textElement.value;\n                if (!value) return;\n                const lang = getInlineCodeLang(value, defaultInlineCodeLang);\n                if (lang && lang[0] !== \".\") {\n                    langsToLoad.add(lang);\n                }\n            }\n            if (isBlockCode(element)) {\n                const codeElement = element.children[0];\n                if (!isElement(codeElement)) return;\n                const { lang } = parseBlockMetaString(codeElement, filterMetaString, defaultCodeBlockLang);\n                if (lang) {\n                    langsToLoad.add(lang);\n                }\n            }\n        });\n        try {\n            await Promise.allSettled(Array.from(langsToLoad).map((lang)=>{\n                try {\n                    return highlighter.loadLanguage(lang);\n                } catch (e) {\n                    return Promise.reject(e);\n                }\n            }));\n        } catch (e) {\n            console.error(e);\n        }\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(tree, \"element\", (element, _, parent)=>{\n            if (isInlineCode(element, parent, bypassInlineCode)) {\n                const textElement = element.children[0];\n                if (!isText(textElement)) return;\n                const value = textElement.value;\n                if (!value) return;\n                const keepLangPart = /\\\\{:[a-zA-Z.-]+}$/.test(value);\n                const strippedValue = keepLangPart ? value.replace(/\\\\({:[a-zA-Z.-]+})$/, \"$1\") : value.replace(/{:[a-zA-Z.-]+}$/, \"\");\n                textElement.value = strippedValue;\n                const lang = keepLangPart ? \"\" : getInlineCodeLang(value, defaultInlineCodeLang);\n                const isLang = lang[0] !== \".\";\n                if (!lang) return;\n                let codeTree;\n                if (isLang) {\n                    try {\n                        codeTree = hastParser.parse(highlighter.codeToHtml(strippedValue, getOptions(lang)));\n                    } catch  {\n                        codeTree = hastParser.parse(highlighter.codeToHtml(strippedValue, getOptions(\"plaintext\")));\n                    }\n                } else {\n                    const themeNames = getThemeNames(theme);\n                    const isMultiTheme = typeof theme === \"object\" && !isJSONTheme(theme);\n                    const themeKeys = isMultiTheme ? Object.keys(theme) : null;\n                    const colorsByTheme = themeNames.map((name)=>name ? highlighter.getTheme(name).settings.find(({ scope })=>scope?.includes(tokensMap[lang.slice(1)] ?? lang.slice(1)))?.settings.foreground ?? \"inherit\" : \"inherit\");\n                    if (isMultiTheme && themeKeys) {\n                        codeTree = hastParser.parse(`<pre><code><span style=\"${themeKeys.map((key2, i)=>`--shiki-${key2}:${colorsByTheme[i]}`).join(\";\")}\">${strippedValue}</span></code></pre>`);\n                    } else {\n                        codeTree = hastParser.parse(`<pre><code><span style=\"color:${colorsByTheme[0]}\">${strippedValue}</span></code></pre>`);\n                    }\n                }\n                (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(codeTree, \"element\", replaceLineClass);\n                apply(element, {\n                    tree: codeTree,\n                    lang: isLang ? lang : \".token\",\n                    inline: true,\n                    keepBackground,\n                    theme\n                });\n            }\n            if (isBlockCode(element)) {\n                const codeElement = element.children[0];\n                if (!isElement(codeElement)) return;\n                const textElement = codeElement.children[0];\n                const { title, caption, meta, lang } = parseBlockMetaString(codeElement, filterMetaString, defaultCodeBlockLang);\n                if (!lang || lang === \"math\") return;\n                const lineNumbers = [];\n                if (meta) {\n                    const matches = meta.matchAll(/\\B\\{(.*?)\\}\\B/g);\n                    for (const match of matches){\n                        if (match[1]) {\n                            lineNumbers.push(...parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__(match[1]));\n                        }\n                    }\n                }\n                let lineNumbersMaxDigits = 0;\n                const lineIdMap = /* @__PURE__ */ new Map();\n                const charsList = [];\n                const charsListNumbers = [];\n                const charsListIdMap = /* @__PURE__ */ new Map();\n                const charsMatches = meta ? [\n                    ...meta.matchAll(/(?<delimiter>[\"/])(?<chars>.*?)\\k<delimiter>(?<charsIdAndOrRange>\\S*)/g)\n                ] : void 0;\n                lineNumbers.forEach((lineNumber)=>{\n                    const id = getLineId(lineNumber, meta);\n                    id && lineIdMap.set(lineNumber, id);\n                });\n                if (Array.isArray(charsMatches)) {\n                    charsMatches.forEach((name)=>{\n                        const { chars, charsIdAndOrRange } = name.groups;\n                        charsList.push(chars);\n                        if (charsIdAndOrRange === \"\") {\n                            charsListNumbers.push([]);\n                        } else {\n                            const [range, id] = charsIdAndOrRange.split(\"#\");\n                            range && charsListNumbers.push(parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__(range));\n                            id && charsListIdMap.set(chars, id);\n                        }\n                    });\n                }\n                if (!isText(textElement)) return;\n                const strippedValue = textElement.value.replace(/\\n$/, \"\");\n                let codeTree;\n                try {\n                    codeTree = hastParser.parse(highlighter.codeToHtml(strippedValue, getOptions(lang, meta)));\n                } catch  {\n                    codeTree = hastParser.parse(highlighter.codeToHtml(strippedValue, getOptions(\"plaintext\", meta)));\n                }\n                let lineCounter = 0;\n                const charsHighlighterOptions = {\n                    ranges: charsListNumbers,\n                    idsMap: charsListIdMap,\n                    counterMap: /* @__PURE__ */ new Map()\n                };\n                (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(codeTree, \"element\", (element2)=>{\n                    if (element2.tagName === \"code\" && /srebmuNeniLwohs(?!(.*)(\\/))/.test(reverseString(meta))) {\n                        if (element2.properties) {\n                            element2.properties[\"data-line-numbers\"] = \"\";\n                        }\n                        const lineNumbersStartAtMatch = reverseString(meta).match(/(?:\\}(\\d+){)?srebmuNeniLwohs(?!(.*)(\\/))/);\n                        const startNumberString = lineNumbersStartAtMatch?.[1];\n                        if (startNumberString) {\n                            const startAt = startNumberString ? Number(reverseString(startNumberString)) - 1 : 0;\n                            lineNumbersMaxDigits = startAt;\n                            if (element2.properties) {\n                                element2.properties.style = `counter-set: line ${startAt};`;\n                            }\n                        }\n                    }\n                    if (Array.isArray(element2.properties?.className) && element2.properties?.className?.[0] === \"line\") {\n                        if (grid && (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(element2) === \"\") {\n                            element2.children = [\n                                {\n                                    type: \"text\",\n                                    value: \" \"\n                                }\n                            ];\n                        }\n                        replaceLineClass(element2);\n                        onVisitLine?.(element2);\n                        lineCounter++;\n                        if (lineNumbers.includes(lineCounter)) {\n                            element2.properties[\"data-highlighted-line\"] = \"\";\n                            const lineId = lineIdMap.get(lineCounter);\n                            if (lineId) {\n                                element2.properties[\"data-highlighted-line-id\"] = lineId;\n                            }\n                            onVisitHighlightedLine?.(element2, lineId);\n                        }\n                        charsHighlighter(element2, charsList, charsHighlighterOptions, onVisitHighlightedChars);\n                        lineNumbersMaxDigits++;\n                    }\n                });\n                apply(element, {\n                    tree: codeTree,\n                    lang,\n                    title,\n                    caption,\n                    keepBackground,\n                    grid,\n                    lineNumbersMaxDigits,\n                    theme,\n                    onVisitTitle,\n                    onVisitCaption\n                });\n            }\n        });\n    };\n}\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVoeXBlLXByZXR0eS1jb2RlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDUDtBQUNNO0FBQ0E7QUFDYjtBQUNLO0FBRXZDLGVBQWU7QUFDZixTQUFTTSxZQUFZQyxLQUFLO0lBQ3hCLE9BQU9BLFFBQVFDLE9BQU9DLE1BQU0sQ0FBQ0YsT0FBTyxpQkFBaUI7QUFDdkQ7QUFDQSxTQUFTRyxVQUFVSCxLQUFLO0lBQ3RCLE9BQU9BLFFBQVFBLE1BQU1JLElBQUksS0FBSyxZQUFZO0FBQzVDO0FBQ0EsU0FBU0MsT0FBT0wsS0FBSztJQUNuQixPQUFPQSxRQUFRQSxNQUFNSSxJQUFJLEtBQUssU0FBUztBQUN6QztBQUNBLFNBQVNFLGFBQWFDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxTQUFTLEtBQUs7SUFDbkQsSUFBSUEsUUFBUTtRQUNWLE9BQU87SUFDVDtJQUNBLE9BQU9GLFFBQVFHLE9BQU8sS0FBSyxVQUFVUCxVQUFVSyxXQUFXQSxPQUFPRSxPQUFPLEtBQUssU0FBU0gsUUFBUUcsT0FBTyxLQUFLO0FBQzVHO0FBQ0EsU0FBU0MsWUFBWUosT0FBTztJQUMxQixPQUFPQSxRQUFRRyxPQUFPLEtBQUssU0FBU0UsTUFBTUMsT0FBTyxDQUFDTixRQUFRTyxRQUFRLEtBQUtQLFFBQVFPLFFBQVEsQ0FBQ0MsTUFBTSxLQUFLLEtBQUtaLFVBQVVJLFFBQVFPLFFBQVEsQ0FBQyxFQUFFLEtBQUtQLFFBQVFPLFFBQVEsQ0FBQyxFQUFFLENBQUNKLE9BQU8sS0FBSztBQUM1SztBQUNBLFNBQVNNLGtCQUFrQkMsSUFBSSxFQUFFQyxtQkFBbUI7SUFDbEQsTUFBTUMsY0FBYztJQUNwQixJQUFJQyxPQUFPSCxLQUFLSSxPQUFPLENBQUMsU0FBU0Y7SUFDakNDLE9BQU9BLEtBQUtDLE9BQU8sQ0FBQyx1QkFBdUI7SUFDM0MsTUFBTUMsT0FBT0YsS0FBS0csS0FBSyxDQUFDLHNCQUFzQixDQUFDLEVB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aW5kZXguanM/OGI3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRTaW5nbGV0b25IaWdobGlnaHRlciB9IGZyb20gJ3NoaWtpJztcbmltcG9ydCB7IHZpc2l0IH0gZnJvbSAndW5pc3QtdXRpbC12aXNpdCc7XG5pbXBvcnQgeyB0b1N0cmluZyB9IGZyb20gJ2hhc3QtdXRpbC10by1zdHJpbmcnO1xuaW1wb3J0IHJhbmdlUGFyc2VyMiBmcm9tICdwYXJzZS1udW1lcmljLXJhbmdlJztcbmltcG9ydCB7IHVuaWZpZWQgfSBmcm9tICd1bmlmaWVkJztcbmltcG9ydCByZWh5cGVQYXJzZSBmcm9tICdyZWh5cGUtcGFyc2UnO1xuXG4vLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIGlzSlNPTlRoZW1lKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/IE9iamVjdC5oYXNPd24odmFsdWUsIFwidG9rZW5Db2xvcnNcIikgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPyB2YWx1ZS50eXBlID09PSBcImVsZW1lbnRcIiA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNUZXh0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/IHZhbHVlLnR5cGUgPT09IFwidGV4dFwiIDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc0lubGluZUNvZGUoZWxlbWVudCwgcGFyZW50LCBieXBhc3MgPSBmYWxzZSkge1xuICBpZiAoYnlwYXNzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBlbGVtZW50LnRhZ05hbWUgPT09IFwiY29kZVwiICYmIGlzRWxlbWVudChwYXJlbnQpICYmIHBhcmVudC50YWdOYW1lICE9PSBcInByZVwiIHx8IGVsZW1lbnQudGFnTmFtZSA9PT0gXCJpbmxpbmVDb2RlXCI7XG59XG5mdW5jdGlvbiBpc0Jsb2NrQ29kZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LnRhZ05hbWUgPT09IFwicHJlXCIgJiYgQXJyYXkuaXNBcnJheShlbGVtZW50LmNoaWxkcmVuKSAmJiBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBpc0VsZW1lbnQoZWxlbWVudC5jaGlsZHJlblswXSkgJiYgZWxlbWVudC5jaGlsZHJlblswXS50YWdOYW1lID09PSBcImNvZGVcIjtcbn1cbmZ1bmN0aW9uIGdldElubGluZUNvZGVMYW5nKG1ldGEsIGRlZmF1bHRGYWxsYmFja0xhbmcpIHtcbiAgY29uc3QgcGxhY2Vob2xkZXIgPSBcIlxcMFwiO1xuICBsZXQgdGVtcCA9IG1ldGEucmVwbGFjZSgvXFxcXFxcXFwvZywgcGxhY2Vob2xkZXIpO1xuICB0ZW1wID0gdGVtcC5yZXBsYWNlKC9cXFxcKHs6W2EtekEtWi4tXSt9KSQvLCBcIiQxXCIpO1xuICBjb25zdCBsYW5nID0gdGVtcC5tYXRjaCgvezooW2EtekEtWi4tXSspfSQvKT8uWzFdO1xuICByZXR1cm4gbGFuZz8ucmVwbGFjZShuZXcgUmVnRXhwKHBsYWNlaG9sZGVyLCBcImdcIiksIFwiXFxcXFwiKSB8fCBkZWZhdWx0RmFsbGJhY2tMYW5nO1xufVxuZnVuY3Rpb24gcGFyc2VCbG9ja01ldGFTdHJpbmcoZWxlbWVudCwgZmlsdGVyLCBkZWZhdWx0RmFsbGJhY2spIHtcbiAgbGV0IG1ldGEgPSBmaWx0ZXIoXG4gICAgZWxlbWVudC5kYXRhPy5tZXRhID8/IGVsZW1lbnQucHJvcGVydGllcz8ubWV0YXN0cmluZyA/PyBcIlwiXG4gICk7XG4gIGNvbnN0IHRpdGxlTWF0Y2ggPSBtZXRhLm1hdGNoKC90aXRsZT1cIihbXlwiXSopXCIvKTtcbiAgY29uc3QgdGl0bGUgPSB0aXRsZU1hdGNoPy5bMV0gPz8gbnVsbDtcbiAgbWV0YSA9IG1ldGEucmVwbGFjZSh0aXRsZU1hdGNoPy5bMF0gPz8gXCJcIiwgXCJcIik7XG4gIGNvbnN0IGNhcHRpb25NYXRjaCA9IG1ldGEubWF0Y2goL2NhcHRpb249XCIoW15cIl0qKVwiLyk7XG4gIGNvbnN0IGNhcHRpb24gPSBjYXB0aW9uTWF0Y2g/LlsxXSA/PyBudWxsO1xuICBtZXRhID0gbWV0YS5yZXBsYWNlKGNhcHRpb25NYXRjaD8uWzBdID8/IFwiXCIsIFwiXCIpO1xuICBsZXQgbGFuZyA9IGRlZmF1bHRGYWxsYmFjaztcbiAgaWYgKGVsZW1lbnQucHJvcGVydGllcyAmJiBBcnJheS5pc0FycmF5KGVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWUpICYmIHR5cGVvZiBlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lWzBdID09PSBcInN0cmluZ1wiICYmIGVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWVbMF0uc3RhcnRzV2l0aChcImxhbmd1YWdlLVwiKSkge1xuICAgIGxhbmcgPSBlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lWzBdLnJlcGxhY2UoXCJsYW5ndWFnZS1cIiwgXCJcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0aXRsZSxcbiAgICBjYXB0aW9uLFxuICAgIGxhbmcsXG4gICAgbWV0YVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VGhlbWVOYW1lcyh0aGVtZSkge1xuICBpZiAoaXNKU09OVGhlbWUodGhlbWUpKSB7XG4gICAgcmV0dXJuIFt0aGVtZS5uYW1lXTtcbiAgfVxuICBpZiAodHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFt0aGVtZV07XG4gIH1cbiAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhlbWUpLm1hcChcbiAgICAodGhlbWUyKSA9PiB0eXBlb2YgdGhlbWUyID09PSBcInN0cmluZ1wiID8gdGhlbWUyIDogdGhlbWUyLm5hbWVcbiAgKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VMaW5lQ2xhc3MoZWxlbWVudCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50LnByb3BlcnRpZXM/LmNsYXNzTmFtZSkgJiYgZWxlbWVudC5wcm9wZXJ0aWVzLmNsYXNzTmFtZS5pbmNsdWRlcyhcImxpbmVcIikpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lLmZpbHRlcigoYykgPT4gYyAhPT0gXCJsaW5lXCIpO1xuICAgIGVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWUgPSBjbGFzc05hbWUubGVuZ3RoID4gMCA/IGNsYXNzTmFtZSA6IHZvaWQgMDtcbiAgICBlbGVtZW50LnByb3BlcnRpZXNbXCJkYXRhLWxpbmVcIl0gPSBcIlwiO1xuICB9XG59XG5mdW5jdGlvbiBnZXRMaW5lSWQobGluZU51bWJlciwgbWV0YSkge1xuICBjb25zdCBzZWdtZW50cyA9IG1ldGEubWF0Y2goL1xce1tefV0rXFx9I1thLXpBLVowLTldKy9nKTtcbiAgaWYgKCFzZWdtZW50cykgcmV0dXJuIG51bGw7XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IFtyYW5nZSwgaWRdID0gc2VnbWVudC5zcGxpdChcIiNcIik7XG4gICAgaWYgKCEocmFuZ2UgJiYgaWQpKSBjb250aW51ZTtcbiAgICBjb25zdCBtYXRjaCA9IHJhbmdlLm1hdGNoKC9cXHsoLio/KVxcfS8pO1xuICAgIGNvbnN0IGNhcHR1cmUgPSBtYXRjaD8uWzFdO1xuICAgIGlmIChjYXB0dXJlICYmIHJhbmdlUGFyc2VyMihjYXB0dXJlKS5pbmNsdWRlcyhsaW5lTnVtYmVyKSkge1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gc3JjL2NoYXJzL3NwbGl0RWxlbWVudC50c1xuZnVuY3Rpb24gc3BsaXRFbGVtZW50KHtcbiAgZWxlbWVudHMsXG4gIGVsZW1lbnRUb1dyYXAsXG4gIGlubmVyU3RyaW5nLFxuICByaWdodFN0cmluZyxcbiAgbGVmdFN0cmluZyxcbiAgcmVzdCxcbiAgbmV4dEVsZW1lbnRDb250aW51ZXMsXG4gIGluZGV4LFxuICBpZ25vcmVDaGFyc1xufSkge1xuICBpZiAoaXNFbGVtZW50KGVsZW1lbnRUb1dyYXApICYmIGVsZW1lbnRUb1dyYXAuY2hpbGRyZW4/LlswXT8udHlwZSAhPT0gXCJ0ZXh0XCIgfHwgaWdub3JlQ2hhcnMpIHtcbiAgICByZXR1cm4gW2VsZW1lbnRUb1dyYXAsIGluZGV4XTtcbiAgfVxuICBsZXQgbmV3SW5kZXggPSBpbmRleDtcbiAgY29uc3QgdGV4dEVsZW1lbnQgPSBlbGVtZW50VG9XcmFwLmNoaWxkcmVuWzBdO1xuICBpZiAoaXNUZXh0KHRleHRFbGVtZW50KSkge1xuICAgIHRleHRFbGVtZW50LnZhbHVlID0gaW5uZXJTdHJpbmc7XG4gIH1cbiAgbGV0IHJpZ2h0U3RyID0gcmlnaHRTdHJpbmc7XG4gIGNvbnN0IGxlZnRTdHIgPSBsZWZ0U3RyaW5nO1xuICBpZiAocmVzdC5sZW5ndGggPiAwKSB7XG4gICAgcmlnaHRTdHIgKz0gcmVzdC5tYXAoKHMpID0+IHMgPT09IFwiXCIgPyBpbm5lclN0cmluZyA6IGlubmVyU3RyaW5nICsgcykuam9pbihcIlwiKTtcbiAgfVxuICBpZiAobGVmdFN0ci5sZW5ndGggPiAwKSB7XG4gICAgZWxlbWVudHMuc3BsaWNlKG5ld0luZGV4LCAwLCB7XG4gICAgICAuLi5lbGVtZW50VG9XcmFwLFxuICAgICAgcHJvcGVydGllczogeyAuLi5lbGVtZW50VG9XcmFwLnByb3BlcnRpZXMgfSxcbiAgICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IGxlZnRTdHIgfV1cbiAgICB9KTtcbiAgfVxuICBpZiAocmlnaHRTdHIubGVuZ3RoID4gMCAmJiAhbmV4dEVsZW1lbnRDb250aW51ZXMpIHtcbiAgICBuZXdJbmRleCA9IGxlZnRTdHIubGVuZ3RoID4gMCA/IG5ld0luZGV4ICsgMiA6IG5ld0luZGV4ICsgMTtcbiAgICBlbGVtZW50cy5zcGxpY2UobmV3SW5kZXgsIDAsIHtcbiAgICAgIC4uLmVsZW1lbnRUb1dyYXAsXG4gICAgICBwcm9wZXJ0aWVzOiB7IC4uLmVsZW1lbnRUb1dyYXAucHJvcGVydGllcyB9LFxuICAgICAgY2hpbGRyZW46IFt7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogcmlnaHRTdHIgfV1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gW2VsZW1lbnRUb1dyYXAsIGluZGV4ICsgMV07XG59XG5mdW5jdGlvbiBuZXh0RWxlbWVudE1heWJlQ29udGludWVzQ2hhcnMoe1xuICBlbGVtZW50cyxcbiAgbmV4dEluZGV4LFxuICByZW1haW5pbmdQYXJ0XG59KSB7XG4gIGlmIChyZW1haW5pbmdQYXJ0ID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG5leHROb2RlID0gZWxlbWVudHNbbmV4dEluZGV4XTtcbiAgY29uc3QgY29udGVudCA9IGdldENvbnRlbnQobmV4dE5vZGUpO1xuICBpZiAoIWNvbnRlbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaW5jbHVkZXNOZXh0ID0gY29udGVudC5zdGFydHNXaXRoKHJlbWFpbmluZ1BhcnQpIHx8IHJlbWFpbmluZ1BhcnQuc3RhcnRzV2l0aChjb250ZW50KTtcbiAgY29uc3Qgb3ZlcmxhcCA9IGZpbmRPdmVybGFwKGNvbnRlbnQsIHJlbWFpbmluZ1BhcnQpO1xuICBpZiAob3ZlcmxhcCA9PT0gcmVtYWluaW5nUGFydCAmJiBjb250ZW50LnN0YXJ0c1dpdGgocmVtYWluaW5nUGFydCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaW5jbHVkZXNOZXh0KSB7XG4gICAgcmV0dXJuIG5leHRFbGVtZW50TWF5YmVDb250aW51ZXNDaGFycyh7XG4gICAgICBlbGVtZW50cyxcbiAgICAgIG5leHRJbmRleDogbmV4dEluZGV4ICsgMSxcbiAgICAgIHJlbWFpbmluZ1BhcnQ6IHJlbWFpbmluZ1BhcnQucmVwbGFjZShjb250ZW50LCBcIlwiKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldENvbnRlbnQobm9kZSkge1xuICBpZiAoIW5vZGUpIHJldHVybjtcbiAgcmV0dXJuIHRvU3RyaW5nKG5vZGUpO1xufVxuZnVuY3Rpb24gZmluZE92ZXJsYXAoYSwgYikge1xuICBpZiAoYi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBpZiAoYS5lbmRzV2l0aChiKSkge1xuICAgIHJldHVybiBiO1xuICB9XG4gIGlmIChhLmluZGV4T2YoYikgPj0gMCkge1xuICAgIHJldHVybiBiO1xuICB9XG4gIHJldHVybiBmaW5kT3ZlcmxhcChhLCBiLnN1YnN0cmluZygwLCBiLmxlbmd0aCAtIDEpKTtcbn1cbmZ1bmN0aW9uIHJldmVyc2VTdHJpbmcocykge1xuICByZXR1cm4gcy5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbn1cblxuLy8gc3JjL2NoYXJzL2dldEVsZW1lbnRzVG9IaWdobGlnaHQudHNcbmZ1bmN0aW9uIGdldEVsZW1lbnRzVG9IaWdobGlnaHQoZWxlbWVudCwgY2hhcnMsIHN0YXJ0SW5kZXggPSAwLCBpZ25vcmVDaGFycyA9IGZhbHNlKSB7XG4gIGNvbnN0IHRvV3JhcCA9IFtdO1xuICBsZXQgY2hhcnNTb0ZhciA9IFwiXCI7XG4gIGlmIChlbGVtZW50LmNoaWxkcmVuKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBlbGVtZW50LmNoaWxkcmVuO1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlbWFpbmluZyA9IGNoYXJzU29GYXIgPyBjaGFycy5yZXBsYWNlKGNoYXJzU29GYXIsIFwiXCIpIDogY2hhcnM7XG4gICAgICBpZiAocmVtYWluaW5nID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiB0b1dyYXA7XG4gICAgICB9XG4gICAgICBjb25zdCBtYXliZUVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmICghbWF5YmVFbGVtZW50IHx8IG1heWJlRWxlbWVudC50eXBlICE9PSBcImVsZW1lbnRcIiB8fCAvLyBpZ25vcmUgYW55IHByZXZpb3VzbHkgbWF0Y2hlZCBjaGFycyB3aXRoaW5cbiAgICAgIE9iamVjdC5oYXNPd24oXG4gICAgICAgIG1heWJlRWxlbWVudC5wcm9wZXJ0aWVzID8/IHt9LFxuICAgICAgICBcInJlaHlwZS1wcmV0dHktY29kZS12aXNpdGVkXCJcbiAgICAgICkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjb250ZW50ID0gZ2V0Q29udGVudChtYXliZUVsZW1lbnQpIHx8IFwiXCI7XG4gICAgICBpZiAoY29udGVudCA9PT0gY2hhcnMgfHwgY2hhcnNTb0ZhciArIGNvbnRlbnQgPT09IGNoYXJzKSB7XG4gICAgICAgIHRvV3JhcC5wdXNoKHsgZWxlbWVudDogbWF5YmVFbGVtZW50LCBpbmRleDogaSB9KTtcbiAgICAgICAgcmV0dXJuIHRvV3JhcDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFycy5zdGFydHNXaXRoKGNoYXJzU29GYXIgKyBjb250ZW50KSkge1xuICAgICAgICBpZiAobmV4dEVsZW1lbnRNYXliZUNvbnRpbnVlc0NoYXJzKHtcbiAgICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgICBuZXh0SW5kZXg6IGkgKyAxLFxuICAgICAgICAgIHJlbWFpbmluZ1BhcnQ6IHJlbWFpbmluZy5yZXBsYWNlKGNvbnRlbnQsIFwiXCIpXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgdG9XcmFwLnB1c2goeyBlbGVtZW50OiBlbGVtZW50c1tpXSwgaW5kZXg6IGkgfSk7XG4gICAgICAgICAgY2hhcnNTb0ZhciArPSBjb250ZW50O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBvdmVybGFwID0gZmluZE92ZXJsYXAoY29udGVudCwgcmVtYWluaW5nKTtcbiAgICAgIGNvbnN0IHBhcnRpYWxNYXRjaCA9IG92ZXJsYXAgJiYgcmVtYWluaW5nLnN0YXJ0c1dpdGgob3ZlcmxhcCk7XG4gICAgICBpZiAocGFydGlhbE1hdGNoKSB7XG4gICAgICAgIGNvbnN0IG5leHRQYXJ0ID0gcmVtYWluaW5nLnJlcGxhY2Uob3ZlcmxhcCwgXCJcIik7XG4gICAgICAgIGlmIChuZXh0UGFydCAhPT0gXCJcIiAmJiBnZXRDb250ZW50KGVsZW1lbnRzW2kgKyAxXSkgJiYgIW5leHRFbGVtZW50TWF5YmVDb250aW51ZXNDaGFycyh7XG4gICAgICAgICAgZWxlbWVudHMsXG4gICAgICAgICAgbmV4dEluZGV4OiBpICsgMSxcbiAgICAgICAgICByZW1haW5pbmdQYXJ0OiBuZXh0UGFydFxuICAgICAgICB9KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwbGl0UGFydHMgPSBjb250ZW50LnNwbGl0KG92ZXJsYXApO1xuICAgICAgICBjb25zdCBbbGVmdFBhcnQsIHJpZ2h0UGFydCwgLi4ucmVzdF0gPSBzcGxpdFBhcnRzO1xuICAgICAgICBpZiAocmlnaHRQYXJ0IHx8IGxlZnRQYXJ0IHx8IHJlc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHdpdGhOZXh0Tm9kZSA9IGNvbnRlbnQgKyAoZ2V0Q29udGVudChlbGVtZW50c1tpICsgMV0pID8gZ2V0Q29udGVudChlbGVtZW50c1tpICsgMV0pIDogXCJcIik7XG4gICAgICAgICAgY29uc3QgbmV4dE5vZGVPdmVybGFwID0gZmluZE92ZXJsYXAod2l0aE5leHROb2RlLCByZW1haW5pbmcpO1xuICAgICAgICAgIGNvbnN0IHNwbGl0SW5kZXggPSB3aXRoTmV4dE5vZGUuaW5kZXhPZihuZXh0Tm9kZU92ZXJsYXApO1xuICAgICAgICAgIGlmIChjaGFycy5lbmRzV2l0aChvdmVybGFwKSB8fCBjaGFycy5zdGFydHNXaXRoKG92ZXJsYXApKSB7XG4gICAgICAgICAgICBjb25zdCByaWdodFN0cmluZyA9IHJpZ2h0UGFydC5yZXBsYWNlKG92ZXJsYXAsIFwiXCIpO1xuICAgICAgICAgICAgY29uc3QgaW5uZXJTdHJpbmcgPSBvdmVybGFwO1xuICAgICAgICAgICAgY29uc3QgbGVmdFN0cmluZyA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIHNwbGl0SW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgbmV4dEVsZW1lbnRDb250aW51ZXMgPSBuZXh0RWxlbWVudE1heWJlQ29udGludWVzQ2hhcnMoe1xuICAgICAgICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgICAgICAgbmV4dEluZGV4OiBpICsgMSxcbiAgICAgICAgICAgICAgcmVtYWluaW5nUGFydDogbmV4dFBhcnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgW25ld0VsZW1lbnQsIHVwZGF0ZWRJbmRleF0gPSBzcGxpdEVsZW1lbnQoe1xuICAgICAgICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgICAgICAgZWxlbWVudFRvV3JhcDogZWxlbWVudHNbaV0sXG4gICAgICAgICAgICAgIGlubmVyU3RyaW5nLFxuICAgICAgICAgICAgICByaWdodFN0cmluZyxcbiAgICAgICAgICAgICAgbGVmdFN0cmluZyxcbiAgICAgICAgICAgICAgcmVzdCxcbiAgICAgICAgICAgICAgbmV4dEVsZW1lbnRDb250aW51ZXMsXG4gICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICBpZ25vcmVDaGFyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjaGFyc1NvRmFyICs9IG92ZXJsYXA7XG4gICAgICAgICAgICB0b1dyYXAucHVzaCh7XG4gICAgICAgICAgICAgIGVsZW1lbnQ6IG5ld0VsZW1lbnQsXG4gICAgICAgICAgICAgIGluZGV4OiB1cGRhdGVkSW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG9XcmFwO1xufVxuXG4vLyBzcmMvY2hhcnMvd3JhcEhpZ2hsaWdodGVkQ2hhcnMudHNcbmZ1bmN0aW9uIHdyYXBIaWdobGlnaHRlZENoYXJzKHBhcmVudEVsZW1lbnQsIGVsZW1lbnRzVG9XcmFwLCBvcHRpb25zLCBpZ25vcmVXb3JkLCBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFycykge1xuICBpZiAoIWVsZW1lbnRzVG9XcmFwIHx8IGVsZW1lbnRzVG9XcmFwLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBbeyBlbGVtZW50IH1dID0gZWxlbWVudHNUb1dyYXA7XG4gIGlmIChpZ25vcmVXb3JkKSB7XG4gICAgaWYgKGVsZW1lbnQucHJvcGVydGllcykge1xuICAgICAgZWxlbWVudC5wcm9wZXJ0aWVzW1wicmVoeXBlLXByZXR0eS1jb2RlLXZpc2l0ZWRcIl0gPSBcIlwiO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnRzVG9XcmFwLmxlbmd0aCA+IDEpIHtcbiAgICBwYXJlbnRFbGVtZW50LmNoaWxkcmVuLnNwbGljZShcbiAgICAgIGVsZW1lbnRzVG9XcmFwWzBdLmluZGV4LFxuICAgICAgZWxlbWVudHNUb1dyYXAubGVuZ3RoLFxuICAgICAge1xuICAgICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgICAgdGFnTmFtZTogXCJtYXJrXCIsXG4gICAgICAgIHByb3BlcnRpZXM6IHsgXCJkYXRhLWhpZ2hsaWdodGVkLWNoYXJzLW1hcmtcIjogXCJcIiB9LFxuICAgICAgICBjaGlsZHJlbjogZWxlbWVudHNUb1dyYXAubWFwKCh7IGVsZW1lbnQ6IGVsZW1lbnQzIH0pID0+IGVsZW1lbnQzKVxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgZWxlbWVudDIgPSBwYXJlbnRFbGVtZW50LmNoaWxkcmVuW2VsZW1lbnRzVG9XcmFwWzBdLmluZGV4XTtcbiAgICBpZiAoIWlzRWxlbWVudChlbGVtZW50MikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd29yZFN0ciA9IGVsZW1lbnQyLmNoaWxkcmVuLnJlZHVjZSgoYWNjLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCB0ZXh0RWxlbWVudCA9IGlzRWxlbWVudChub2RlKSA/IG5vZGUuY2hpbGRyZW5bMF0gOiBudWxsO1xuICAgICAgaWYgKGlzVGV4dCh0ZXh0RWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGFjYyArIHRleHRFbGVtZW50LnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBcIlwiKTtcbiAgICBjb25zdCBpZCA9IG9wdGlvbnMuaWRzTWFwLmdldCh3b3JkU3RyKTtcbiAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzID0gZWxlbWVudDIucHJvcGVydGllcyB8fCB7fTtcbiAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzW1wiZGF0YS1oaWdobGlnaHRlZC1jaGFyc1wiXSA9IFwiXCI7XG4gICAgZWxlbWVudDIucHJvcGVydGllc1tcImRhdGEtY2hhcnMtaWRcIl0gPSBpZDtcbiAgICBlbGVtZW50Mi50YWdOYW1lID0gXCJtYXJrXCI7XG4gICAgb25WaXNpdEhpZ2hsaWdodGVkQ2hhcnM/LihlbGVtZW50MiwgaWQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFt7IGVsZW1lbnQ6IGVsZW1lbnQyIH1dID0gZWxlbWVudHNUb1dyYXA7XG4gICAgY29uc3QgdGV4dEVsZW1lbnQgPSBlbGVtZW50Mi5jaGlsZHJlblswXTtcbiAgICBpZiAoIWlzVGV4dCh0ZXh0RWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBvcHRpb25zLmlkc01hcC5nZXQodGV4dEVsZW1lbnQudmFsdWUpO1xuICAgIGVsZW1lbnQyLnByb3BlcnRpZXMgPSBlbGVtZW50Mi5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJyZWh5cGUtcHJldHR5LWNvZGUtdmlzaXRlZFwiXSA9IFwiXCI7XG4gICAgZWxlbWVudDIucHJvcGVydGllc1tcImRhdGEtaGlnaGxpZ2h0ZWQtY2hhcnNcIl0gPSBcIlwiO1xuICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJkYXRhLWNoYXJzLWlkXCJdID0gaWQ7XG4gICAgZWxlbWVudDIudGFnTmFtZSA9IFwibWFya1wiO1xuICAgIGVsZW1lbnQyLmNoaWxkcmVuID0gW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgICAgdGFnTmFtZTogXCJzcGFuXCIsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBzdHlsZTogZWxlbWVudDIucHJvcGVydGllcy5zdHlsZVxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogZWxlbWVudDIuY2hpbGRyZW5cbiAgICAgIH1cbiAgICBdO1xuICAgIGVsZW1lbnQyLnByb3BlcnRpZXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgb25WaXNpdEhpZ2hsaWdodGVkQ2hhcnM/LihlbGVtZW50MiwgaWQpO1xuICB9XG59XG5mdW5jdGlvbiBjaGFyc0hpZ2hsaWdodGVyKGVsZW1lbnQsIGNoYXJzTGlzdCwgb3B0aW9ucywgb25WaXNpdEhpZ2hsaWdodGVkQ2hhcnMpIHtcbiAgY29uc3QgeyByYW5nZXMgPSBbXSB9ID0gb3B0aW9ucztcbiAgY29uc3QgdGV4dENvbnRlbnQgPSB0b1N0cmluZyhlbGVtZW50KTtcbiAgY2hhcnNMaXN0LmZvckVhY2goKGNoYXJzLCBpbmRleCkgPT4ge1xuICAgIGlmIChjaGFycyAmJiB0ZXh0Q29udGVudD8uaW5jbHVkZXMoY2hhcnMpKSB7XG4gICAgICBsZXQgdGV4dENvbnRlbnQyID0gdG9TdHJpbmcoZWxlbWVudCk7XG4gICAgICBsZXQgc3RhcnRJbmRleCA9IDA7XG4gICAgICB3aGlsZSAodGV4dENvbnRlbnQyLmluY2x1ZGVzKGNoYXJzKSkge1xuICAgICAgICBjb25zdCBjdXJyZW50Q2hhcnNSYW5nZSA9IHJhbmdlc1tpbmRleF0gfHwgW107XG4gICAgICAgIGNvbnN0IGlkID0gYCR7Y2hhcnN9LSR7aW5kZXh9YDtcbiAgICAgICAgb3B0aW9ucy5jb3VudGVyTWFwLnNldChpZCwgKG9wdGlvbnMuY291bnRlck1hcC5nZXQoaWQpIHx8IDApICsgMSk7XG4gICAgICAgIGNvbnN0IGlnbm9yZUNoYXJzID0gY3VycmVudENoYXJzUmFuZ2UubGVuZ3RoID4gMCAmJiAhY3VycmVudENoYXJzUmFuZ2UuaW5jbHVkZXMob3B0aW9ucy5jb3VudGVyTWFwLmdldChpZCkgPz8gLTEpO1xuICAgICAgICBjb25zdCBlbGVtZW50c1RvV3JhcCA9IGdldEVsZW1lbnRzVG9IaWdobGlnaHQoXG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICBjaGFycyxcbiAgICAgICAgICBzdGFydEluZGV4LFxuICAgICAgICAgIGlnbm9yZUNoYXJzXG4gICAgICAgICk7XG4gICAgICAgIGlmIChlbGVtZW50c1RvV3JhcC5sZW5ndGggPT09IDApIGJyZWFrO1xuICAgICAgICB3cmFwSGlnaGxpZ2h0ZWRDaGFycyhcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIGVsZW1lbnRzVG9XcmFwLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgaWdub3JlQ2hhcnMsXG4gICAgICAgICAgb25WaXNpdEhpZ2hsaWdodGVkQ2hhcnNcbiAgICAgICAgKTtcbiAgICAgICAgc3RhcnRJbmRleCA9IE1hdGgubWF4KFxuICAgICAgICAgIGVsZW1lbnRzVG9XcmFwW2VsZW1lbnRzVG9XcmFwLmxlbmd0aCAtIDFdLmluZGV4IC0gMixcbiAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIHRleHRDb250ZW50MiA9IGVsZW1lbnQuY2hpbGRyZW4ubWFwKChjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICBjb25zdCBwcm9wcyA9IGlzRWxlbWVudChjaGlsZE5vZGUpID8gY2hpbGROb2RlLnByb3BlcnRpZXMgOiB7fTtcbiAgICAgICAgICBpZiAocHJvcHMgJiYgIU9iamVjdC5oYXNPd24ocHJvcHMsIFwicmVoeXBlLXByZXR0eS1jb2RlLXZpc2l0ZWRcIikgJiYgIU9iamVjdC5oYXNPd24ocHJvcHMsIFwiZGF0YS1oaWdobGlnaHRlZC1jaGFycy1tYXJrXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9TdHJpbmcoY2hpbGROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZWxlbWVudC5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHtcbiAgICBpZiAoIWlzRWxlbWVudChjaGlsZE5vZGUpKSByZXR1cm47XG4gICAgaWYgKE9iamVjdC5oYXNPd24oY2hpbGROb2RlLnByb3BlcnRpZXMsIFwicmVoeXBlLXByZXR0eS1jb2RlLXZpc2l0ZWRcIikpIHtcbiAgICAgIGNoaWxkTm9kZS5wcm9wZXJ0aWVzW1wicmVoeXBlLXByZXR0eS1jb2RlLXZpc2l0ZWRcIl0gPSB2b2lkIDA7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5mdW5jdGlvbiBhcHBseShlbGVtZW50LCB7XG4gIHRyZWUsXG4gIGxhbmcsXG4gIHRpdGxlLFxuICBjYXB0aW9uLFxuICBpbmxpbmUgPSBmYWxzZSxcbiAga2VlcEJhY2tncm91bmQgPSB0cnVlLFxuICBncmlkID0gdHJ1ZSxcbiAgbGluZU51bWJlcnNNYXhEaWdpdHMgPSAxLFxuICB0aGVtZSxcbiAgb25WaXNpdFRpdGxlLFxuICBvblZpc2l0Q2FwdGlvblxufSkge1xuICBlbGVtZW50LnRhZ05hbWUgPSBpbmxpbmUgPyBcInNwYW5cIiA6IFwiZmlndXJlXCI7XG4gIGVsZW1lbnQucHJvcGVydGllc1tcImRhdGEtcmVoeXBlLXByZXR0eS1jb2RlLWZpZ3VyZVwiXSA9IFwiXCI7XG4gIGNvbnN0IGNvZGVEYXRhID0gZWxlbWVudC5jaGlsZHJlblswXT8uZGF0YTtcbiAgZWxlbWVudC5jaGlsZHJlbiA9IFt0cmVlXS5mbGF0TWFwKCh0cmVlMikgPT4ge1xuICAgIGNvbnN0IHByZSA9IHRyZWUyLmNoaWxkcmVuWzBdO1xuICAgIGNvbnN0IHRoZW1lTmFtZXMgPSBnZXRUaGVtZU5hbWVzKHRoZW1lKTtcbiAgICBjb25zdCB0aGVtZU5hbWVzU3RyaW5nID0gdGhlbWVOYW1lcy5qb2luKFwiIFwiKTtcbiAgICBpZiAoIShpc0VsZW1lbnQocHJlKSAmJiBwcmUucHJvcGVydGllcykpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgY29kZSA9IHByZS5jaGlsZHJlblswXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcmUucHJvcGVydGllcy5jbGFzc05hbWUpICYmIHByZS5wcm9wZXJ0aWVzLmNsYXNzTmFtZS5pbmNsdWRlcyhcInNoaWtpXCIpKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWUgPSBwcmUucHJvcGVydGllcy5jbGFzc05hbWUuZmlsdGVyKFxuICAgICAgICAoYykgPT4gYyAhPT0gXCJzaGlraVwiICYmIGMgIT09IFwic2hpa2ktdGhlbWVzXCIgJiYgKHR5cGVvZiBjID09PSBcInN0cmluZ1wiID8gIXRoZW1lTmFtZXMuaW5jbHVkZXMoYykgOiB0cnVlKVxuICAgICAgKTtcbiAgICAgIHByZS5wcm9wZXJ0aWVzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZS5sZW5ndGggPiAwID8gY2xhc3NOYW1lIDogdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoIWtlZXBCYWNrZ3JvdW5kKSB7XG4gICAgICBwcmUucHJvcGVydGllcy5zdHlsZSA9IHZvaWQgMDtcbiAgICB9XG4gICAgcHJlLnByb3BlcnRpZXNbXCJkYXRhLWxhbmd1YWdlXCJdID0gbGFuZztcbiAgICBwcmUucHJvcGVydGllc1tcImRhdGEtdGhlbWVcIl0gPSB0aGVtZU5hbWVzU3RyaW5nO1xuICAgIGlmICghKGlzRWxlbWVudChjb2RlKSAmJiBjb2RlLnByb3BlcnRpZXMpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvZGUucHJvcGVydGllc1tcImRhdGEtbGFuZ3VhZ2VcIl0gPSBsYW5nO1xuICAgIGNvZGUucHJvcGVydGllc1tcImRhdGEtdGhlbWVcIl0gPSB0aGVtZU5hbWVzU3RyaW5nO1xuICAgIGNvZGUuZGF0YSA9IGNvZGVEYXRhO1xuICAgIGlmIChpbmxpbmUpIHtcbiAgICAgIGlmIChrZWVwQmFja2dyb3VuZCkge1xuICAgICAgICBjb2RlLnByb3BlcnRpZXMuc3R5bGUgPSBwcmUucHJvcGVydGllcy5zdHlsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICBpZiAoZ3JpZCkge1xuICAgICAgaWYgKGNvZGUucHJvcGVydGllcy5zdHlsZSkge1xuICAgICAgICBjb2RlLnByb3BlcnRpZXMuc3R5bGUgKz0gXCJkaXNwbGF5OiBncmlkO1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZS5wcm9wZXJ0aWVzLnN0eWxlID0gXCJkaXNwbGF5OiBncmlkO1wiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoT2JqZWN0Lmhhc093bihjb2RlLnByb3BlcnRpZXMsIFwiZGF0YS1saW5lLW51bWJlcnNcIikpIHtcbiAgICAgIGNvZGUucHJvcGVydGllc1tcImRhdGEtbGluZS1udW1iZXJzLW1heC1kaWdpdHNcIl0gPSBsaW5lTnVtYmVyc01heERpZ2l0cy50b1N0cmluZygpLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgZnJhZ21lbnRzID0gW107XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBjb25zdCBlbGVtZW50Q29udGVudCA9IHtcbiAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgIHRhZ05hbWU6IGNhcHRpb24gPyBcImRpdlwiIDogXCJmaWdjYXB0aW9uXCIsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBcImRhdGEtcmVoeXBlLXByZXR0eS1jb2RlLXRpdGxlXCI6IFwiXCIsXG4gICAgICAgICAgXCJkYXRhLWxhbmd1YWdlXCI6IGxhbmcsXG4gICAgICAgICAgXCJkYXRhLXRoZW1lXCI6IHRoZW1lTmFtZXNTdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IFt7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogdGl0bGUgfV1cbiAgICAgIH07XG4gICAgICBvblZpc2l0VGl0bGU/LihlbGVtZW50Q29udGVudCk7XG4gICAgICBmcmFnbWVudHMucHVzaChlbGVtZW50Q29udGVudCk7XG4gICAgfVxuICAgIGZyYWdtZW50cy5wdXNoKHByZSk7XG4gICAgaWYgKGNhcHRpb24pIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRDb250ZW50ID0ge1xuICAgICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgICAgdGFnTmFtZTogXCJmaWdjYXB0aW9uXCIsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBcImRhdGEtcmVoeXBlLXByZXR0eS1jb2RlLWNhcHRpb25cIjogXCJcIixcbiAgICAgICAgICBcImRhdGEtbGFuZ3VhZ2VcIjogbGFuZyxcbiAgICAgICAgICBcImRhdGEtdGhlbWVcIjogdGhlbWVOYW1lc1N0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogW3sgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBjYXB0aW9uIH1dXG4gICAgICB9O1xuICAgICAgb25WaXNpdENhcHRpb24/LihlbGVtZW50Q29udGVudCk7XG4gICAgICBmcmFnbWVudHMucHVzaChlbGVtZW50Q29udGVudCk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudHM7XG4gIH0pO1xufVxudmFyIGdsb2JhbEhpZ2hsaWdodGVyQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xudmFyIGhhc3RQYXJzZXIgPSB1bmlmaWVkKCkudXNlKHJlaHlwZVBhcnNlLCB7IGZyYWdtZW50OiB0cnVlIH0pO1xudmFyIHNyY19kZWZhdWx0ID0gcmVoeXBlUHJldHR5Q29kZTtcbmZ1bmN0aW9uIHJlaHlwZVByZXR0eUNvZGUob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBncmlkID0gdHJ1ZSxcbiAgICB0aGVtZSA9IFwiZ2l0aHViLWRhcmstZGltbWVkXCIsXG4gICAga2VlcEJhY2tncm91bmQgPSB0cnVlLFxuICAgIGJ5cGFzc0lubGluZUNvZGUgPSBmYWxzZSxcbiAgICBkZWZhdWx0TGFuZyA9IFwiXCIsXG4gICAgdG9rZW5zTWFwID0ge30sXG4gICAgZmlsdGVyTWV0YVN0cmluZyA9ICh2KSA9PiB2LFxuICAgIGdldEhpZ2hsaWdodGVyID0gZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXIsXG4gICAgdHJhbnNmb3JtZXJzLFxuICAgIG9uVmlzaXRMaW5lLFxuICAgIG9uVmlzaXRIaWdobGlnaHRlZExpbmUsXG4gICAgb25WaXNpdEhpZ2hsaWdodGVkQ2hhcnMsXG4gICAgb25WaXNpdFRpdGxlLFxuICAgIG9uVmlzaXRDYXB0aW9uXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeSh0aGVtZSk7XG4gIGxldCBjYWNoZWRIaWdobGlnaHRlciA9IGdsb2JhbEhpZ2hsaWdodGVyQ2FjaGUuZ2V0KGtleSk7XG4gIGlmICghY2FjaGVkSGlnaGxpZ2h0ZXIpIHtcbiAgICBjYWNoZWRIaWdobGlnaHRlciA9IGdldEhpZ2hsaWdodGVyKHtcbiAgICAgIHRoZW1lczogaXNKU09OVGhlbWUodGhlbWUpIHx8IHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIiA/IFt0aGVtZV0gOiBPYmplY3QudmFsdWVzKHRoZW1lKSxcbiAgICAgIGxhbmdzOiBbXCJwbGFpbnRleHRcIl1cbiAgICB9KTtcbiAgICBnbG9iYWxIaWdobGlnaHRlckNhY2hlLnNldChrZXksIGNhY2hlZEhpZ2hsaWdodGVyKTtcbiAgfVxuICBjb25zdCBkZWZhdWx0Q29kZUJsb2NrTGFuZyA9IHR5cGVvZiBkZWZhdWx0TGFuZyA9PT0gXCJzdHJpbmdcIiA/IGRlZmF1bHRMYW5nIDogZGVmYXVsdExhbmcuYmxvY2sgfHwgXCJcIjtcbiAgY29uc3QgZGVmYXVsdElubGluZUNvZGVMYW5nID0gdHlwZW9mIGRlZmF1bHRMYW5nID09PSBcInN0cmluZ1wiID8gZGVmYXVsdExhbmcgOiBkZWZhdWx0TGFuZy5pbmxpbmUgfHwgXCJcIjtcbiAgZnVuY3Rpb24gZ2V0T3B0aW9ucyhsYW5nLCBtZXRhKSB7XG4gICAgY29uc3QgbXVsdGlwbGVUaGVtZXMgPSAhaXNKU09OVGhlbWUodGhlbWUpICYmIHR5cGVvZiB0aGVtZSA9PT0gXCJvYmplY3RcIiA/IHRoZW1lIDogbnVsbDtcbiAgICBjb25zdCBzaW5nbGVUaGVtZSA9IGlzSlNPTlRoZW1lKHRoZW1lKSB8fCB0eXBlb2YgdGhlbWUgPT09IFwic3RyaW5nXCIgPyB0aGVtZSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhbmcsXG4gICAgICBtZXRhOiB7IF9fcmF3OiBtZXRhIH0sXG4gICAgICB0cmFuc2Zvcm1lcnMsXG4gICAgICBkZWZhdWx0Q29sb3I6IHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIiA/IHRoZW1lIDogZmFsc2UsXG4gICAgICAuLi5tdWx0aXBsZVRoZW1lcyA/IHsgdGhlbWVzOiBtdWx0aXBsZVRoZW1lcyB9IDogeyB0aGVtZTogc2luZ2xlVGhlbWUgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGFzeW5jICh0cmVlKSA9PiB7XG4gICAgY29uc3QgbGFuZ3NUb0xvYWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IGhpZ2hsaWdodGVyID0gYXdhaXQgY2FjaGVkSGlnaGxpZ2h0ZXI7XG4gICAgaWYgKCFoaWdobGlnaHRlcikgcmV0dXJuO1xuICAgIHZpc2l0KHRyZWUsIFwiZWxlbWVudFwiLCAoZWxlbWVudCwgXywgcGFyZW50KSA9PiB7XG4gICAgICBpZiAoaXNJbmxpbmVDb2RlKGVsZW1lbnQsIHBhcmVudCwgYnlwYXNzSW5saW5lQ29kZSkpIHtcbiAgICAgICAgY29uc3QgdGV4dEVsZW1lbnQgPSBlbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgICAgICBpZiAoIWlzVGV4dCh0ZXh0RWxlbWVudCkpIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0ZXh0RWxlbWVudC52YWx1ZTtcbiAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBsYW5nID0gZ2V0SW5saW5lQ29kZUxhbmcodmFsdWUsIGRlZmF1bHRJbmxpbmVDb2RlTGFuZyk7XG4gICAgICAgIGlmIChsYW5nICYmIGxhbmdbMF0gIT09IFwiLlwiKSB7XG4gICAgICAgICAgbGFuZ3NUb0xvYWQuYWRkKGxhbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNCbG9ja0NvZGUoZWxlbWVudCkpIHtcbiAgICAgICAgY29uc3QgY29kZUVsZW1lbnQgPSBlbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgICAgICBpZiAoIWlzRWxlbWVudChjb2RlRWxlbWVudCkpIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBsYW5nIH0gPSBwYXJzZUJsb2NrTWV0YVN0cmluZyhcbiAgICAgICAgICBjb2RlRWxlbWVudCxcbiAgICAgICAgICBmaWx0ZXJNZXRhU3RyaW5nLFxuICAgICAgICAgIGRlZmF1bHRDb2RlQmxvY2tMYW5nXG4gICAgICAgICk7XG4gICAgICAgIGlmIChsYW5nKSB7XG4gICAgICAgICAgbGFuZ3NUb0xvYWQuYWRkKGxhbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChcbiAgICAgICAgQXJyYXkuZnJvbShsYW5nc1RvTG9hZCkubWFwKChsYW5nKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBoaWdobGlnaHRlci5sb2FkTGFuZ3VhZ2UoXG4gICAgICAgICAgICAgIGxhbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gICAgdmlzaXQodHJlZSwgXCJlbGVtZW50XCIsIChlbGVtZW50LCBfLCBwYXJlbnQpID0+IHtcbiAgICAgIGlmIChpc0lubGluZUNvZGUoZWxlbWVudCwgcGFyZW50LCBieXBhc3NJbmxpbmVDb2RlKSkge1xuICAgICAgICBjb25zdCB0ZXh0RWxlbWVudCA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIGlmICghaXNUZXh0KHRleHRFbGVtZW50KSkgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRleHRFbGVtZW50LnZhbHVlO1xuICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGtlZXBMYW5nUGFydCA9IC9cXFxcezpbYS16QS1aLi1dK30kLy50ZXN0KHZhbHVlKTtcbiAgICAgICAgY29uc3Qgc3RyaXBwZWRWYWx1ZSA9IGtlZXBMYW5nUGFydCA/IHZhbHVlLnJlcGxhY2UoL1xcXFwoezpbYS16QS1aLi1dK30pJC8sIFwiJDFcIikgOiB2YWx1ZS5yZXBsYWNlKC97OlthLXpBLVouLV0rfSQvLCBcIlwiKTtcbiAgICAgICAgdGV4dEVsZW1lbnQudmFsdWUgPSBzdHJpcHBlZFZhbHVlO1xuICAgICAgICBjb25zdCBsYW5nID0ga2VlcExhbmdQYXJ0ID8gXCJcIiA6IGdldElubGluZUNvZGVMYW5nKHZhbHVlLCBkZWZhdWx0SW5saW5lQ29kZUxhbmcpO1xuICAgICAgICBjb25zdCBpc0xhbmcgPSBsYW5nWzBdICE9PSBcIi5cIjtcbiAgICAgICAgaWYgKCFsYW5nKSByZXR1cm47XG4gICAgICAgIGxldCBjb2RlVHJlZTtcbiAgICAgICAgaWYgKGlzTGFuZykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb2RlVHJlZSA9IGhhc3RQYXJzZXIucGFyc2UoXG4gICAgICAgICAgICAgIGhpZ2hsaWdodGVyLmNvZGVUb0h0bWwoc3RyaXBwZWRWYWx1ZSwgZ2V0T3B0aW9ucyhsYW5nKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBjb2RlVHJlZSA9IGhhc3RQYXJzZXIucGFyc2UoXG4gICAgICAgICAgICAgIGhpZ2hsaWdodGVyLmNvZGVUb0h0bWwoc3RyaXBwZWRWYWx1ZSwgZ2V0T3B0aW9ucyhcInBsYWludGV4dFwiKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHRoZW1lTmFtZXMgPSBnZXRUaGVtZU5hbWVzKHRoZW1lKTtcbiAgICAgICAgICBjb25zdCBpc011bHRpVGhlbWUgPSB0eXBlb2YgdGhlbWUgPT09IFwib2JqZWN0XCIgJiYgIWlzSlNPTlRoZW1lKHRoZW1lKTtcbiAgICAgICAgICBjb25zdCB0aGVtZUtleXMgPSBpc011bHRpVGhlbWUgPyBPYmplY3Qua2V5cyh0aGVtZSkgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IGNvbG9yc0J5VGhlbWUgPSB0aGVtZU5hbWVzLm1hcChcbiAgICAgICAgICAgIChuYW1lKSA9PiBuYW1lID8gaGlnaGxpZ2h0ZXIuZ2V0VGhlbWUobmFtZSkuc2V0dGluZ3MuZmluZChcbiAgICAgICAgICAgICAgKHsgc2NvcGUgfSkgPT4gc2NvcGU/LmluY2x1ZGVzKHRva2Vuc01hcFtsYW5nLnNsaWNlKDEpXSA/PyBsYW5nLnNsaWNlKDEpKVxuICAgICAgICAgICAgKT8uc2V0dGluZ3MuZm9yZWdyb3VuZCA/PyBcImluaGVyaXRcIiA6IFwiaW5oZXJpdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaXNNdWx0aVRoZW1lICYmIHRoZW1lS2V5cykge1xuICAgICAgICAgICAgY29kZVRyZWUgPSBoYXN0UGFyc2VyLnBhcnNlKFxuICAgICAgICAgICAgICBgPHByZT48Y29kZT48c3BhbiBzdHlsZT1cIiR7dGhlbWVLZXlzLm1hcCgoa2V5MiwgaSkgPT4gYC0tc2hpa2ktJHtrZXkyfToke2NvbG9yc0J5VGhlbWVbaV19YCkuam9pbihcIjtcIil9XCI+JHtzdHJpcHBlZFZhbHVlfTwvc3Bhbj48L2NvZGU+PC9wcmU+YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29kZVRyZWUgPSBoYXN0UGFyc2VyLnBhcnNlKFxuICAgICAgICAgICAgICBgPHByZT48Y29kZT48c3BhbiBzdHlsZT1cImNvbG9yOiR7Y29sb3JzQnlUaGVtZVswXX1cIj4ke3N0cmlwcGVkVmFsdWV9PC9zcGFuPjwvY29kZT48L3ByZT5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aXNpdChjb2RlVHJlZSwgXCJlbGVtZW50XCIsIHJlcGxhY2VMaW5lQ2xhc3MpO1xuICAgICAgICBhcHBseShlbGVtZW50LCB7XG4gICAgICAgICAgdHJlZTogY29kZVRyZWUsXG4gICAgICAgICAgbGFuZzogaXNMYW5nID8gbGFuZyA6IFwiLnRva2VuXCIsXG4gICAgICAgICAgaW5saW5lOiB0cnVlLFxuICAgICAgICAgIGtlZXBCYWNrZ3JvdW5kLFxuICAgICAgICAgIHRoZW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzQmxvY2tDb2RlKGVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IGNvZGVFbGVtZW50ID0gZWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgaWYgKCFpc0VsZW1lbnQoY29kZUVsZW1lbnQpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHRleHRFbGVtZW50ID0gY29kZUVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIGNvbnN0IHsgdGl0bGUsIGNhcHRpb24sIG1ldGEsIGxhbmcgfSA9IHBhcnNlQmxvY2tNZXRhU3RyaW5nKFxuICAgICAgICAgIGNvZGVFbGVtZW50LFxuICAgICAgICAgIGZpbHRlck1ldGFTdHJpbmcsXG4gICAgICAgICAgZGVmYXVsdENvZGVCbG9ja0xhbmdcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFsYW5nIHx8IGxhbmcgPT09IFwibWF0aFwiKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGxpbmVOdW1iZXJzID0gW107XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IG1ldGEubWF0Y2hBbGwoL1xcQlxceyguKj8pXFx9XFxCL2cpO1xuICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgIGxpbmVOdW1iZXJzLnB1c2goLi4ucmFuZ2VQYXJzZXIyKG1hdGNoWzFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBsaW5lTnVtYmVyc01heERpZ2l0cyA9IDA7XG4gICAgICAgIGNvbnN0IGxpbmVJZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGNoYXJzTGlzdCA9IFtdO1xuICAgICAgICBjb25zdCBjaGFyc0xpc3ROdW1iZXJzID0gW107XG4gICAgICAgIGNvbnN0IGNoYXJzTGlzdElkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgY2hhcnNNYXRjaGVzID0gbWV0YSA/IFtcbiAgICAgICAgICAuLi5tZXRhLm1hdGNoQWxsKFxuICAgICAgICAgICAgLyg/PGRlbGltaXRlcj5bXCIvXSkoPzxjaGFycz4uKj8pXFxrPGRlbGltaXRlcj4oPzxjaGFyc0lkQW5kT3JSYW5nZT5cXFMqKS9nXG4gICAgICAgICAgKVxuICAgICAgICBdIDogdm9pZCAwO1xuICAgICAgICBsaW5lTnVtYmVycy5mb3JFYWNoKChsaW5lTnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBnZXRMaW5lSWQobGluZU51bWJlciwgbWV0YSk7XG4gICAgICAgICAgaWQgJiYgbGluZUlkTWFwLnNldChsaW5lTnVtYmVyLCBpZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGFyc01hdGNoZXMpKSB7XG4gICAgICAgICAgY2hhcnNNYXRjaGVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhcnMsIGNoYXJzSWRBbmRPclJhbmdlIH0gPSBuYW1lLmdyb3VwcztcbiAgICAgICAgICAgIGNoYXJzTGlzdC5wdXNoKGNoYXJzKTtcbiAgICAgICAgICAgIGlmIChjaGFyc0lkQW5kT3JSYW5nZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICBjaGFyc0xpc3ROdW1iZXJzLnB1c2goW10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgW3JhbmdlLCBpZF0gPSBjaGFyc0lkQW5kT3JSYW5nZS5zcGxpdChcIiNcIik7XG4gICAgICAgICAgICAgIHJhbmdlICYmIGNoYXJzTGlzdE51bWJlcnMucHVzaChyYW5nZVBhcnNlcjIocmFuZ2UpKTtcbiAgICAgICAgICAgICAgaWQgJiYgY2hhcnNMaXN0SWRNYXAuc2V0KGNoYXJzLCBpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1RleHQodGV4dEVsZW1lbnQpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHN0cmlwcGVkVmFsdWUgPSB0ZXh0RWxlbWVudC52YWx1ZS5yZXBsYWNlKC9cXG4kLywgXCJcIik7XG4gICAgICAgIGxldCBjb2RlVHJlZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb2RlVHJlZSA9IGhhc3RQYXJzZXIucGFyc2UoXG4gICAgICAgICAgICBoaWdobGlnaHRlci5jb2RlVG9IdG1sKHN0cmlwcGVkVmFsdWUsIGdldE9wdGlvbnMobGFuZywgbWV0YSkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgY29kZVRyZWUgPSBoYXN0UGFyc2VyLnBhcnNlKFxuICAgICAgICAgICAgaGlnaGxpZ2h0ZXIuY29kZVRvSHRtbChcbiAgICAgICAgICAgICAgc3RyaXBwZWRWYWx1ZSxcbiAgICAgICAgICAgICAgZ2V0T3B0aW9ucyhcInBsYWludGV4dFwiLCBtZXRhKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmVDb3VudGVyID0gMDtcbiAgICAgICAgY29uc3QgY2hhcnNIaWdobGlnaHRlck9wdGlvbnMgPSB7XG4gICAgICAgICAgcmFuZ2VzOiBjaGFyc0xpc3ROdW1iZXJzLFxuICAgICAgICAgIGlkc01hcDogY2hhcnNMaXN0SWRNYXAsXG4gICAgICAgICAgY291bnRlck1hcDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICAgICAgICB9O1xuICAgICAgICB2aXNpdChjb2RlVHJlZSwgXCJlbGVtZW50XCIsIChlbGVtZW50MikgPT4ge1xuICAgICAgICAgIGlmIChlbGVtZW50Mi50YWdOYW1lID09PSBcImNvZGVcIiAmJiAvc3JlYm11TmVuaUx3b2hzKD8hKC4qKShcXC8pKS8udGVzdChyZXZlcnNlU3RyaW5nKG1ldGEpKSkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQyLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgZWxlbWVudDIucHJvcGVydGllc1tcImRhdGEtbGluZS1udW1iZXJzXCJdID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpbmVOdW1iZXJzU3RhcnRBdE1hdGNoID0gcmV2ZXJzZVN0cmluZyhtZXRhKS5tYXRjaChcbiAgICAgICAgICAgICAgLyg/OlxcfShcXGQrKXspP3NyZWJtdU5lbmlMd29ocyg/ISguKikoXFwvKSkvXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnROdW1iZXJTdHJpbmcgPSBsaW5lTnVtYmVyc1N0YXJ0QXRNYXRjaD8uWzFdO1xuICAgICAgICAgICAgaWYgKHN0YXJ0TnVtYmVyU3RyaW5nKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXJ0QXQgPSBzdGFydE51bWJlclN0cmluZyA/IE51bWJlcihyZXZlcnNlU3RyaW5nKHN0YXJ0TnVtYmVyU3RyaW5nKSkgLSAxIDogMDtcbiAgICAgICAgICAgICAgbGluZU51bWJlcnNNYXhEaWdpdHMgPSBzdGFydEF0O1xuICAgICAgICAgICAgICBpZiAoZWxlbWVudDIucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQyLnByb3BlcnRpZXMuc3R5bGUgPSBgY291bnRlci1zZXQ6IGxpbmUgJHtzdGFydEF0fTtgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQyLnByb3BlcnRpZXM/LmNsYXNzTmFtZSkgJiYgZWxlbWVudDIucHJvcGVydGllcz8uY2xhc3NOYW1lPy5bMF0gPT09IFwibGluZVwiKSB7XG4gICAgICAgICAgICBpZiAoZ3JpZCAmJiB0b1N0cmluZyhlbGVtZW50MikgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgZWxlbWVudDIuY2hpbGRyZW4gPSBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IFwiIFwiIH1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVwbGFjZUxpbmVDbGFzcyhlbGVtZW50Mik7XG4gICAgICAgICAgICBvblZpc2l0TGluZT8uKGVsZW1lbnQyKTtcbiAgICAgICAgICAgIGxpbmVDb3VudGVyKys7XG4gICAgICAgICAgICBpZiAobGluZU51bWJlcnMuaW5jbHVkZXMobGluZUNvdW50ZXIpKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJkYXRhLWhpZ2hsaWdodGVkLWxpbmVcIl0gPSBcIlwiO1xuICAgICAgICAgICAgICBjb25zdCBsaW5lSWQgPSBsaW5lSWRNYXAuZ2V0KGxpbmVDb3VudGVyKTtcbiAgICAgICAgICAgICAgaWYgKGxpbmVJZCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJkYXRhLWhpZ2hsaWdodGVkLWxpbmUtaWRcIl0gPSBsaW5lSWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb25WaXNpdEhpZ2hsaWdodGVkTGluZT8uKGVsZW1lbnQyLCBsaW5lSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhcnNIaWdobGlnaHRlcihcbiAgICAgICAgICAgICAgZWxlbWVudDIsXG4gICAgICAgICAgICAgIGNoYXJzTGlzdCxcbiAgICAgICAgICAgICAgY2hhcnNIaWdobGlnaHRlck9wdGlvbnMsXG4gICAgICAgICAgICAgIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGluZU51bWJlcnNNYXhEaWdpdHMrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhcHBseShlbGVtZW50LCB7XG4gICAgICAgICAgdHJlZTogY29kZVRyZWUsXG4gICAgICAgICAgbGFuZyxcbiAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICBjYXB0aW9uLFxuICAgICAgICAgIGtlZXBCYWNrZ3JvdW5kLFxuICAgICAgICAgIGdyaWQsXG4gICAgICAgICAgbGluZU51bWJlcnNNYXhEaWdpdHMsXG4gICAgICAgICAgdGhlbWUsXG4gICAgICAgICAgb25WaXNpdFRpdGxlLFxuICAgICAgICAgIG9uVmlzaXRDYXB0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnQgeyBzcmNfZGVmYXVsdCBhcyBkZWZhdWx0LCByZWh5cGVQcmV0dHlDb2RlIH07XG4iXSwibmFtZXMiOlsiZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXIiLCJ2aXNpdCIsInRvU3RyaW5nIiwicmFuZ2VQYXJzZXIyIiwidW5pZmllZCIsInJlaHlwZVBhcnNlIiwiaXNKU09OVGhlbWUiLCJ2YWx1ZSIsIk9iamVjdCIsImhhc093biIsImlzRWxlbWVudCIsInR5cGUiLCJpc1RleHQiLCJpc0lubGluZUNvZGUiLCJlbGVtZW50IiwicGFyZW50IiwiYnlwYXNzIiwidGFnTmFtZSIsImlzQmxvY2tDb2RlIiwiQXJyYXkiLCJpc0FycmF5IiwiY2hpbGRyZW4iLCJsZW5ndGgiLCJnZXRJbmxpbmVDb2RlTGFuZyIsIm1ldGEiLCJkZWZhdWx0RmFsbGJhY2tMYW5nIiwicGxhY2Vob2xkZXIiLCJ0ZW1wIiwicmVwbGFjZSIsImxhbmciLCJtYXRjaCIsIlJlZ0V4cCIsInBhcnNlQmxvY2tNZXRhU3RyaW5nIiwiZmlsdGVyIiwiZGVmYXVsdEZhbGxiYWNrIiwiZGF0YSIsInByb3BlcnRpZXMiLCJtZXRhc3RyaW5nIiwidGl0bGVNYXRjaCIsInRpdGxlIiwiY2FwdGlvbk1hdGNoIiwiY2FwdGlvbiIsImNsYXNzTmFtZSIsInN0YXJ0c1dpdGgiLCJnZXRUaGVtZU5hbWVzIiwidGhlbWUiLCJuYW1lIiwidmFsdWVzIiwibWFwIiwidGhlbWUyIiwicmVwbGFjZUxpbmVDbGFzcyIsImluY2x1ZGVzIiwiYyIsImdldExpbmVJZCIsImxpbmVOdW1iZXIiLCJzZWdtZW50cyIsInNlZ21lbnQiLCJyYW5nZSIsImlkIiwic3BsaXQiLCJjYXB0dXJlIiwic3BsaXRFbGVtZW50IiwiZWxlbWVudHMiLCJlbGVtZW50VG9XcmFwIiwiaW5uZXJTdHJpbmciLCJyaWdodFN0cmluZyIsImxlZnRTdHJpbmciLCJyZXN0IiwibmV4dEVsZW1lbnRDb250aW51ZXMiLCJpbmRleCIsImlnbm9yZUNoYXJzIiwibmV3SW5kZXgiLCJ0ZXh0RWxlbWVudCIsInJpZ2h0U3RyIiwibGVmdFN0ciIsInMiLCJqb2luIiwic3BsaWNlIiwibmV4dEVsZW1lbnRNYXliZUNvbnRpbnVlc0NoYXJzIiwibmV4dEluZGV4IiwicmVtYWluaW5nUGFydCIsIm5leHROb2RlIiwiY29udGVudCIsImdldENvbnRlbnQiLCJpbmNsdWRlc05leHQiLCJvdmVybGFwIiwiZmluZE92ZXJsYXAiLCJub2RlIiwiYSIsImIiLCJlbmRzV2l0aCIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJyZXZlcnNlU3RyaW5nIiwicmV2ZXJzZSIsImdldEVsZW1lbnRzVG9IaWdobGlnaHQiLCJjaGFycyIsInN0YXJ0SW5kZXgiLCJ0b1dyYXAiLCJjaGFyc1NvRmFyIiwiaSIsInJlbWFpbmluZyIsIm1heWJlRWxlbWVudCIsInB1c2giLCJwYXJ0aWFsTWF0Y2giLCJuZXh0UGFydCIsInNwbGl0UGFydHMiLCJsZWZ0UGFydCIsInJpZ2h0UGFydCIsIndpdGhOZXh0Tm9kZSIsIm5leHROb2RlT3ZlcmxhcCIsInNwbGl0SW5kZXgiLCJuZXdFbGVtZW50IiwidXBkYXRlZEluZGV4Iiwid3JhcEhpZ2hsaWdodGVkQ2hhcnMiLCJwYXJlbnRFbGVtZW50IiwiZWxlbWVudHNUb1dyYXAiLCJvcHRpb25zIiwiaWdub3JlV29yZCIsIm9uVmlzaXRIaWdobGlnaHRlZENoYXJzIiwiZWxlbWVudDMiLCJlbGVtZW50MiIsIndvcmRTdHIiLCJyZWR1Y2UiLCJhY2MiLCJpZHNNYXAiLCJnZXQiLCJzdHlsZSIsImNoYXJzSGlnaGxpZ2h0ZXIiLCJjaGFyc0xpc3QiLCJyYW5nZXMiLCJ0ZXh0Q29udGVudCIsImZvckVhY2giLCJ0ZXh0Q29udGVudDIiLCJjdXJyZW50Q2hhcnNSYW5nZSIsImNvdW50ZXJNYXAiLCJzZXQiLCJNYXRoIiwibWF4IiwiY2hpbGROb2RlIiwicHJvcHMiLCJhcHBseSIsInRyZWUiLCJpbmxpbmUiLCJrZWVwQmFja2dyb3VuZCIsImdyaWQiLCJsaW5lTnVtYmVyc01heERpZ2l0cyIsIm9uVmlzaXRUaXRsZSIsIm9uVmlzaXRDYXB0aW9uIiwiY29kZURhdGEiLCJmbGF0TWFwIiwidHJlZTIiLCJwcmUiLCJ0aGVtZU5hbWVzIiwidGhlbWVOYW1lc1N0cmluZyIsImNvZGUiLCJmcmFnbWVudHMiLCJlbGVtZW50Q29udGVudCIsImdsb2JhbEhpZ2hsaWdodGVyQ2FjaGUiLCJNYXAiLCJoYXN0UGFyc2VyIiwidXNlIiwiZnJhZ21lbnQiLCJzcmNfZGVmYXVsdCIsInJlaHlwZVByZXR0eUNvZGUiLCJieXBhc3NJbmxpbmVDb2RlIiwiZGVmYXVsdExhbmciLCJ0b2tlbnNNYXAiLCJmaWx0ZXJNZXRhU3RyaW5nIiwidiIsImdldEhpZ2hsaWdodGVyIiwidHJhbnNmb3JtZXJzIiwib25WaXNpdExpbmUiLCJvblZpc2l0SGlnaGxpZ2h0ZWRMaW5lIiwia2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsImNhY2hlZEhpZ2hsaWdodGVyIiwidGhlbWVzIiwibGFuZ3MiLCJkZWZhdWx0Q29kZUJsb2NrTGFuZyIsImJsb2NrIiwiZGVmYXVsdElubGluZUNvZGVMYW5nIiwiZ2V0T3B0aW9ucyIsIm11bHRpcGxlVGhlbWVzIiwic2luZ2xlVGhlbWUiLCJfX3JhdyIsImRlZmF1bHRDb2xvciIsImxhbmdzVG9Mb2FkIiwiU2V0IiwiaGlnaGxpZ2h0ZXIiLCJfIiwiYWRkIiwiY29kZUVsZW1lbnQiLCJQcm9taXNlIiwiYWxsU2V0dGxlZCIsImZyb20iLCJsb2FkTGFuZ3VhZ2UiLCJlIiwicmVqZWN0IiwiY29uc29sZSIsImVycm9yIiwia2VlcExhbmdQYXJ0IiwidGVzdCIsInN0cmlwcGVkVmFsdWUiLCJpc0xhbmciLCJjb2RlVHJlZSIsInBhcnNlIiwiY29kZVRvSHRtbCIsImlzTXVsdGlUaGVtZSIsInRoZW1lS2V5cyIsImtleXMiLCJjb2xvcnNCeVRoZW1lIiwiZ2V0VGhlbWUiLCJzZXR0aW5ncyIsImZpbmQiLCJzY29wZSIsInNsaWNlIiwiZm9yZWdyb3VuZCIsImtleTIiLCJsaW5lTnVtYmVycyIsIm1hdGNoZXMiLCJtYXRjaEFsbCIsImxpbmVJZE1hcCIsImNoYXJzTGlzdE51bWJlcnMiLCJjaGFyc0xpc3RJZE1hcCIsImNoYXJzTWF0Y2hlcyIsImNoYXJzSWRBbmRPclJhbmdlIiwiZ3JvdXBzIiwibGluZUNvdW50ZXIiLCJjaGFyc0hpZ2hsaWdodGVyT3B0aW9ucyIsImxpbmVOdW1iZXJzU3RhcnRBdE1hdGNoIiwic3RhcnROdW1iZXJTdHJpbmciLCJzdGFydEF0IiwiTnVtYmVyIiwibGluZUlkIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rehype-pretty-code/dist/index.js\n");

/***/ })

};
;